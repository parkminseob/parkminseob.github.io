# ArrayList

* toArray()의 목적
  ArrayList에 보관되어있는 인스턴스 목록을 배열로 리턴하는 것.
  어떤 타입이든 담을 수 있게 Object[]타입으로 리턴된다. 제네릭을 쓰더라도 내부적으로 어차피 Object[]타입으로 형변환 된다.



* 배열의 크기를 늘릴 때(grow) 자바에서 제공하는 Arrays클래스를 이용하기 
* 반복을 통해 기존 배열을 새로만든 배열에 복사하는 방법을 써도 되지만 기본으로 제공하는 copyOf()를 통해 코드가 더 간결해진다.

   ` elementData = Arrays.copyOf(elementData, newCapacity);`

여기서 copyOf의 1번은 기존 복사할 배열의 데이터, 2번은 새로만든 빈배열 . 메서드를 통해 복사된 값이 최종적으로 elementData로 들어간다.



* 배열의 항목을 삭제할 때 배열 복사 기능 이용하기
  ArrayList는 특정 인덱스를 삭제할때, 기존 배열을 복사해서 한칸씩 왼쪽으로 잘라붙인다. 역시 for문을 써도 되지만 자바에서 기본으로 제공하는 System.arrayCopy()를 써서 해결해보자.

형식 : arrayCopy(Object src, int srcPos, object dest, int destPos, length)

```
파라미터
src - 복사대상
srcPos - 복사할 항목의 시작 인덱스
dest - 목적지
destPos - 복사 목적지 인덱스
length - 복사할 항목의 개수
```

```java
    System.arraycopy(
        elementData, 
        index+1, // 삭제할 인덱스 +1부터 복사를 시작한다.
        elementData, 
        index, // 삭제할 인덱스 부터 배열을 붙여넣기한다.
        this.size-(index+1)); // 기존배열 사이즈 - (삭제할 인덱스+1)
}
```



* 파라미터로 받은 배열에 값을 채워주는 toArray(E[])메서드를 추가하기.

  => 기존의 Object[] toArray()와 다른것이 뭔가?
  	 기존 Object[] toArray()는 배열을 무조건 Object로 바꿔서 리턴한다.

  ​	 ==E[] toArray는 파라미터로 E[] 배열의 레퍼런스 e를 받는다.==

  ​	// 윗줄 : 형광펜 테스트

     기존의 Object[]배열과 다르게 (E[])로 리턴된다. 
  => 귀찮게 (E[])로 형변환 할 필요 없이 바로 리턴해주니 이런 메서드도 생긴 것이라고 추측함



newInstance() - 동적객체 생성

* 클래스명에 무엇을 넣느냐에 따라 어떤 객체가 만들어지느냐가 갈린다. 이렇게 되면 입력값 혹은 파라미터를 여러개의 조건문으로 하지 않고도 바로 어떤 객체인지를 판단하여 만들 수 있기 때문에 코드가 간결해진다.
* new 연산자를 사용하지 않아도 동적으로 객체를 생성할 수 있다. 이 방법은 코드 작성 시에 클래스 이름을 결정할 수 없고, 런타임 시에 클래스 이름이 결정되는 경우에 매우 유용하게 사용될 수 있다.
* 리턴타입은 Object이다. 그래서 원래 클래스 타입으로 형변환 해야함

**도저히 뭔소린지 모르겠으니 Class class를 배우고 다시 복습해보자**



제네릭 배열

E[] arr 는 되는데 왜 new E[]는 안돼는가?

그 이유는 new 연산자 때문이다. new 연산자는 heap 영역에 충분한 공간이 있는지 확인한 후 메모리를 확보하는 역할을 한다. 충분한 공간이 있는지 확인하려면 타입을 알아야한다. 그런데 컴파일 시점에 타입 T 가 무엇인지 알 수 없기 때문에 new T[5] 와 같이 **제네릭으로 배열을 생성할 수는 없다.**

**static 변수에도 제네릭을 사용할 수 없다.** static 변수는 인스턴스에 종속되지 않는 클래스변수로써 모든 인스턴스가 공통된 저장공간을 공유하게 되는 변수이다.

하지만 static 메서드에는 제네릭을 사용할 수 있다고?

스태틱 메서드의 선언부에 제네릭을 사용하면 ok, 그러나 파라미터안에 들어간 제네릭은 허용되지 않는 문법



자바프로젝트 15부터 진행중~ 진행완료

// 추상 메서드를 선언하는 의미?

// - 서브 클래스에 구현을 강제하는 문법.

//

// 메서드 구현을 강제한다는 의미?

// - 해당 객체가 반드시 갖춰야 할 기능을 선언하는 것.

// - 즉 객체의 사용법(사용규칙)을 명시하는 효과.

//

// 객체의 구현 방법에 영향을 받지 않는 메서드를 따로 분리하여

// 별도의 사용 규칙으로 정의하게 되면,

// 좀 더 유연하고 교체하기 쉬운 구조로 코드를 관리할 수 있다.

//

// 초보자를 위한 실무 공식:

// - 추상 클래스를 정의한 다음 추상 메서드를 설정한다.

// - 추상 메서드는 인터페이스 문법을 사용하여 별도로 분리한다.

// - 클래스에서 사용 규칙(메서드 호출 규칙)을 따로 분리해서 정의해 두면

//   좀 더 다양한 하위 클래스를 정의하고 다룰 수 있다.

// - 추상 메서드가 대부분인 경우 인터페이스로 정의하는 것이 낫다.

//   왜?

//   추상 클래스의 목적이 하위 클래스에게 공통 필드나 메서드를 상속해 주는 것인데,

//   대부분의 메서드가 추상 메서드라서 서브 클래스 입장에서 딱히 도움이 안되는 상황일 때

//   그냥 메서드 사용 규칙만 정의하는 것이 코드 관리에 낫기 때문이다.



어려웠던 부분 - CRUD 코드 추가하는거.. 알고리즘은 너무 어렵다

내일은 새로운 문법인 중첩클래스를 배울예정.
그리고 알고리즘 하루에 1문제씩 풀기..



