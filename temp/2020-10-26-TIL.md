blocking = pending = 소켓을 리턴하지 않고 기다리는 상태

소켓을 통해 다이렉트로 클라이언트의 주소를 알아낼 수 는 없고 InetSocketAddress에 담아서 그 객체를 통해 주소와 포트를 알아내야한다 -> 확장성을 위해

각 스레드는 개인적인 스택메모리를 가지고있다.

즉 스택 메모리는 스레드가 관리한다. : 어떤 메소드를 호출하면 그 메소드의 로컬 변수들은 스레드가 관리하는거임



stateless방식에서 서버가 클라이언트를 구분하는 방법은 클ㄹ라이언트가 자신의 정보를 보내주는 방법밖에없다.



\#### index

\- 검색 조건으로 사용되는 컬럼인 경우 따로 정렬해 두면 데이터를 찾을 때 빨리 찾을 수 있다.

\- 특정 컬럼의 값을 A-Z 또는 Z-A로 정렬시키는 문법이 인덱스이다.

\- DBMS는 해당 컬럼의 값으로 정렬한 데이터 정보를 별도의 파일로 생성한다.

\- 보통 책 맨 뒤에 붙어있는 색인표와 같다.

\- 인덱스로 지정된 컬럼의 값이 추가/변경/삭제 될 때 인덱스 정보도 갱신한다.

\- 따라서 입력/변경/삭제가 자주 발생하는 테이블에 대해 인덱스 컬럼을 지정하면,

 입력/변경/삭제 시 인덱스 정보를 갱신해야 하기 때문에

 입력/변경/삭제 속도가 느려지는 문제가 있다.

\- 대신 조회 속도는 빠르다.



ex sq101

색인표를 생성하면 단점 : HDD용량이 증가한다.

장점 : 검색 속도가 빠르다!

표를 기준 항목에 대해 정렬하는것. = 색인표

새 Data추가, Data변경, Data삭제 => 색인표 갱신(추가/변경/삭제 시)시 색인표 매번 갱신 : 실행속도가 느림. 대신 검색속도 빠름!



색인기능에서 데이터를 앞에추가하던 뒤에추가하던 그것은 아무 상관이 없다.

create view worker

 as select no, name, class from test1 where working = 'Y';

뷰를 생성해서 가상테이블로 만들기

별도 테이블이 생성되는게 아니라 셀렉트 한 것을 worker로 축약한것임.

뷰를 조회할 때 마다 select문장을 실행한다.

DDL (data definition language) : sql문법중에서 데이터를 정의해주는 문법



ex sql02

DML(data manipulation language)

pk가 auto increment라면 꼭 값을 넣지 않아도 된다.

stateless에서 Thread를 쓸 수 밖에 없는 이유



-------

sql

 primary key (주 키)

 \- candidate key 중에서 DBMS 관리자가 사용하기로 결정한 키

 \- 예) DBMS 관리자가 id 컬럼의 값을 데이터를 구분하는 키로 사용하기로 결정했다면,

  \- 주 키는, {id} 가 된다.

  \- 주 키로 선택되지 않은 모든 candidate key는 alternate key가 된다.

\- alternate key (대안 키)

 \- candidate key 중에서 primary key로 선택된 키를 제외한 나머지 키.

 \- 비록 primary key는 아니지만, primary key 처럼 데이터를 구분하는

  용도로 대신 사용할 수 있다고 해서 **대안 키(alternate key)** 라 부른다.



\#### artificial key (인공키)

\- Primary key로 사용하기에 적절한 컬럼을 찾을 수 없다면,

 \- 예) 게시글 : 제목, 내용, 작성자, 등록일, 조회수

\- 이런 경우에 key로 사용할 컬럼을 추가한다.

\- 보통 일련번호를 저장할 정수 타입의 컬럼을 추가한다.

 \- 예) 게시글 : 게시글 번호

\- 대부분의 SNS 서비스들은 일련의 번호를 primary key 사용한다.

\- 왜?

 \- 회원 탈퇴의 경우,

  \- 회원 탈퇴할 때 아이디도 제거한다.

  \- 아이디를 지우면 그 아이디와 연결된 게시글을 지워야 한다.

  \- 그런데 회원 아이디 대신 일련 번호를 사용하면,

  \- 그 회원이 쓴 게시글은 일련번호와 묶인다.

  \- 따라서 아이디가 삭제되더라도 해당 글은 계속 유효하게 처리할 수 있다.

 \- 이메일 변경,

  \- primary key 값은 다른 데이터에서 사용하기 때문에,

   \- 예) 게시글을 저장할 때 회원 이메일을 저장한다고 가정하자.

  \- pk 값을 변경하면 그 값을 사용한 모든 데이터에 영향을 끼친다.

  \- 그래서 PK 값을 다른 데이터에서 사용한 경우,

   DBMS는 PK 값을 변경하지 못하도록 통제한다.

  \- 이렇게 값을 변경될 수 있는 경우에는 PK로 사용하지 말라.

  \- 대신 회원 번호와 같은 임의의 키(인공 키)를 만들어 사용하는 것이 좋다.