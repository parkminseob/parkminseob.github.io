---
title: "상속과 다형성"
toc : true
categories:
  - Java
tags:
  - Java
  - Java basic
  - OOP
---

## 상속

아래는 자바 API에서 명시한 상속의 개념이다.
* *Class Object is the root of the class hierarchy. Every class has Object as a superclass. All objects, including arrays, implement the methods of this class.*

* 자바의 모든 프로젝트는 Object의 직계,손자,등등등 어쨌든 다 오브젝트를 상속받았다.
그 Object클래스에 .toString() .equals() .hashCode() .getClass() .clone()같은 유우명한 메소드가 들어있다!

* 현실에서의 상속과 다르게 프로그램에선 자식(서브클래스)이 조상(수퍼클래스)클래스를 선택한 뒤에 extends를 뒤에 기술한다.
```java
class 자식클래스 extends 엄마클래스 {
 //필드
 //생성자
 //메소드
}
```
* extends 명령으로 상속을 하면 바로 상속 클래스가 로딩되는게 아니라 클래스 필드를 실행한뒤 생성자 안의 super();클래스 생성자를 호출하면 그때 수퍼클래스가 로딩된다. 수퍼클래스와 관계없이 서브클래스에서 생성자와 인스턴스 변수는 무한정 생성 가능하다.
```java
public Car () {
  //super(); // 상속할때 기본적으로 생성되는 수퍼클래스 생성자
  }
```

-> 자바에서는 여러개의 조상클래스를 상속할 수 없다! 단 하나뿐.
-> 조상클래스에서 private 접근 제한을 갖는 필드와 메소드는 상속 대상에서 제외된다.

### 상속이 필요한 이유
-----------------------
oop-ex05패키지

계산기 프로그램이 있다. 이 계산기를 고객사에 납품했다. 그리고 개발자가 새로운 프로그램을 추가하였다. 
프로그램에 새 기능을 추가한다고 모든 고객사가 그걸 반기는게 아니였다.
그래서 프로토타입 계산기는 그대로 두고, 코드를 복붙하고 새기능을 추가해서 납품하는 식으로 했으나... 무한복붙을 하다보니 버전이 무한정 늘어나기 시작했다. 그 와중 잘 쓰던 프로그램에 아주 치명적인 버그가 발생해버리면??? 그리고 고객사가 100개이상이 넘어간다면?! 아주 난리가 나버리는 것이다. 버그를 잡기 위해 개발자가 회사를 10개씩 떠맡아 출장만 다니는 비효율적인 기간이 생긴다.
그래서 상속이란 문법이 등장했다. 상속받은 제일 처음의 클래스만 버그를 잡아주면 나머지도 유지보수가 아주 쉬워졌음!!
![](https://images.velog.io/images/minseobcms/post/71e6c188-5160-4383-82df-f2cfb7444341/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7,%202020-08-11%2019-56-19.png)

상속이란 단어때문에 헷갈릴 수 있다. 한국어에선 상속이 그대로 물려받는다는 뜻이기 때문에 기존의 코드를 그대로 복붙한다고 이해하면 곤란하다. 상속은 기존의 코드를 복사하는 것이 아닌, 기존의 코드를 확장하여 쓰겠다고 선언하는 것이다. 즉 상속은 상속받은 클래스의 링크정보를 가지고 있는 것이다.


## 추상화
내가 일을하는데 컴퓨터를 활용해서 처리하고싶다.
그렇게 하려면 내가 업무에서 다루는 사람이나 사물개념에 대해 분석을 한 후 그 특징을 데이터와 메소드로 정의한 것을 추상화라고 한다.

사물 개념에 대해 분석한다는 것은?
-> 같은 책이라도 중고서점에 다루는 책의 특징과 폐지공장에서 다루는 책의 특징은 매우 다르다. 
-> 중고서점에서는 책의 오염도, 파손도 등을 다루겠지만 폐지공장에선 책의 그램수나 재질이 중요할 것이다.


## 코드사용 범위제어

캡슐화 (추후에 배울 예정)

## 다형성 

oop ex06패키지 

상속받은 코드 작성을 용이하게 해주는 것.
다양한 객체를 이용해서 다양한 실행결과가 나오도록 하는 성질이다.
예를 들어, 자동차가 타이어를 사용하는 방법은 동일하지만 어떤 타이어를 사용(장착)하느냐에 따라 주행 성능이 달라질 수 있다.

* 자동타입변환
클래스의 변환은 상속관계에 있는 클래스 사이에서 발생한다. 서브클래스는 수퍼클래스 타입으로 자동 타입 변환이 가능하다. 바로 위의 조상이 아니더라도 상속 계층에서 상위타입이면 자동 타입 변환이 일어날 수 있다.
왜!! 자동 타입 변환이 필요한가요? 그냥 서브클래스 사용하면 안돼나..?
-> 필드의 타입을 조상타입으로 선언하면 다양한 자식 객체들이 저장될 수 있기 때문에 필드 사용 결과가 달라질 수 있다. 이것이 **필드의 다형성**이다!

* 다형적 변수
하위 클래스의 레퍼런스로 상위 클래스의 인스턴스를 가리킬 수 없다.
=> 상위 클래스의 인스턴스에는 하위 클래스의 인스턴스 변수가 없을 수 있기 때문이다.










