---
title: 자바 - 객체지향 프로그래밍
layout: single
read_time: true
comments: true
share: true
related: true
categories:
- Java
toc: true
toc_sticky: true
toc_label: on this page
tags:
  - Java
  - Java basic
---

![java-logo](https://user-images.githubusercontent.com/68311188/91867408-9797e400-ecae-11ea-846c-22adf8b1d152.jpg)


### 객체지향 프로그래밍
------------------------------
객체란 물리적으로나 추상적으로나 자신의 속성을 가지고 있으면서 식별 가능한 것을 말한다.  
객체는 속성(필드)과 동작(메서드)로 구분된다. 메모리에서 사용하고 싶은 객체가 있다면 우선 설계도를 통해 해당 객체를 만드는 작업이 필요하다.  
자바에서는 설계도를 클래스라고 부른다.  
이 클래스로부터 만들어진 객체를 **인스턴스** 라고 부른다.

#### 클래스
---------------------
일반적으로 자바 소스파일 하나당 하나의 클래스를 선언한다. 하지만 2개 이상의 클래스 선언도 가능하다.  
```java
public class car {}
	class Tire[]
```
2개 이상의 클래스를  선언한 소스파일을 컴파일 하면 바이트코드파일은 클래스를 선언한 개수 만큼 생긴다.  
=> 결국 소스 파일은 클래스 선언을 담고 있는 저장단위일 뿐, 클래스 자체는 아니다!

클래스는 두 가지 용도가 있다.  
**1. 라이브러리 클래스**
  -> 다른 클래스에서 이용할 목적으로 설계됨

**2. 실행 클래스**  
   -> 프로그램의 실행 진입점인main()메소드를 제공하는 역할을 한다.  
==> 프로그램 전체에서 사용되는 클래스가 100개라면 99개가 라이브러리, 단 하나가 실행클래스이다! 라이브러리와 실행클래스가 한 소스파일에 있는 경우도 있지만 대부분의 객체지향 프로그래밍은 라이브러리와 실행클래스가 분리되어있다.

* 클래스의 구성멤버
각 구성멤버는 생략되거나 복수로 작성이 가능하다.

**1. 필드**  
   객체의 고유 데이터, 상태를 저장한다. 선언형태는 변수와 비슷하다. 하지만 필드는 생성자와 메소드 전체에서 사용되며 객체가 소멸되기 않는 한 객체와 존재하기 때문에 일반적인 변수와는 다르다. 클래스 변수라고도 부르지만 필드라고 제대로 불러주자!

**2. 생성자**  
   new 연산자로 호출되는 특별한 중괄호 블럭. 메소드와 비슷하게 생겼지만 클래스 이름으로 되어있고 리턴타입이 없다.  

**3. 메소드**


#### 메소드
---------------------------
메소드는 다양한 기능을 담은 함수이다. (함수=메소드)  
리턴값이 있을 때도 있고 없을 때도 있다.   
> 리턴값이란? 실행한 후의 결과값.
리턴값을 돌려받을 땐 리턴 타입이 선언부에 명시되어있어야 한다. 리턴타입이 없다면 void를 사용해준다. void를 사용하는 메소드도 return을 사용할 수 있으나 이때의 return은 메소드를 강제종료 시키는 역할을 한다.  
메소드 호출은 클래스로부터 객체를 생성한 뒤에 레퍼런스를 통해 호출할 수 있다.

* 메소드의 오버로딩
클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것을 메소드 오버로딩(overloading)이라고 한다.
오버로딩의 사전적 의미 : 많이 싣는 것

오버로딩이 왜 필요한가? 매개값을 다양하게 받아 처리할 수 있도록 하기 위함이다!

```java
예제 1) 다양한 타입의 plus 메소드
int plus(int x, int y) {
    int result = x + y;
    return result;
  }
  
  double plus (double x, double y) {
    double result = x + y;
    return result;
  }
```

오버로딩된 메소드를 호출할 경우 JVM은 매개값의 타입을 보고 메소드를 선택한다.

예2) 정사각형/직사각형 넓이를 구하는 두개의 오버로딩된 메소드
```java
double areaRectangle(double x) {
    return = x * x;
  }
double areaRectangle(double x, double y) {
    return = x * y;
  }
```
로컬에서 호출하는 메소드에 따라 직사각형, 정사각형 둘중 하나를 골라 연산한다.

#### static 멤버와 인스턴스 멤버
클래스의 필드는 객체가 요구하는 필요성에 따라 두가지로 구분해서 선언할 수 있다.  
객체마다 가지고 있어야 할 데이터라면 인스턴스필드, 객체마다 가지고 있을 필요가 없는 공동 데이터라면 스태틱필드로 선언해준다.

1. 인스턴스 멤버 : 객체마다 가지고 있는 멤버 (모든 객체가 다 공유하지는 않음)
2. 스태틱 멤버 : 객체들이 모두 사용할 수 있는 공동 멤버.

* 인스턴스멤버
객체 생성 후 사용할 수 있는 필드와 메소드. 각각 인스턴스 필드, 인스턴스 메소드라고 부른다. 인스턴스 필드와 메소드는 객체에 소속된 멤버이기 떄문에 객체 없이는 사용할 수 없다!   
내가 여태까지 연습했던 거의 대다수 필드와 메소드는 인스턴스 멤버였다.

객체 내부에서 인스턴스 멤버에 접근하기 위해 this 사용 가능. (내장되어있음!!)  
this는 주로 생성자와 메소드의 매개 변수 이름이 필드와 동일한 경우, 인스턴스 멤버인 필드임을 명시하고자 할 때 사용된다.


* 스태틱 멤버
객체를 생성하지 않고 사용할 수 있는 필드와 메소드
메소드 영역에 생성된다.

객체가 없어도 실행된다는 특징 떄문에 정적 메소드를 선언할 때는 이들 내부에 인스턴스 필드나 인스턴스 메소드를 사용할 수 없다. 그러므로 this키워드도 사용 불가능!
```java
static class Math {
    // 다음 메서드와 같이 인스턴스 변수를 사용하지 않고 
    // 파라미터 값을 가지고 작업하는 경우에 보통 클래스 메서드로 정의한다.
    public static int abs(int value) {
      if (value < 0)
        return value * -1;
      return value;
    }
```
정적메소드에서 인스턴스 멤버 사용하고 싶으면 정적 메소드 내에서 객체를 생성하고 참조 변수로 접근해야한다.  
--> 메소드끼리 호출할때도 객체생성이 필요하다는 것~~  
프로그램을 짤 때 처음부터 스태틱/인스턴스를 구분하고자 하면 만들기가 굉장히 힘들기 때문에 일단 전부 인스턴스로 만든 다음 정말 고정된 값이 나을 것 같을 경우에만 스태틱으로 고치는걸 권장한다.